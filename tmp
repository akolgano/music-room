"""
ASGI config for musicroom project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application
#from channels.staticfiles import StaticFilesWrapper
from django.contrib.staticfiles.handlers import ASGIStaticFilesHandler
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from apps.playlists.routing import websocket_urlpatterns

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = ProtocolTypeRouter({
    "http": ASGIStaticFilesHandler(get_asgi_application()),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})
"""
Django settings for musicroom project.

Generated by 'django-admin startproject' using Django 4.2.11.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-)j^i^$)^7mn*v@fui9uwxy(+^mw7x+5y%m1s_n+!e*4^ovk^#7'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework.authtoken',
    'apps.deezer',
    'apps.users',
    'apps.tracks',
    'apps.playlists',
    'apps.devices',
    'corsheaders',
    'channels',
    'apps.remote_auth',
    'apps.profile',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'
ASGI_APPLICATION = 'core.asgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv("POSTGRES_DB", None),
        'USER': os.getenv("POSTGRES_USER", None),
        "PASSWORD": os.getenv("POSTGRES_PASSWORD", None),
        "HOST": os.getenv("POSTGRES_HOST", None),
        "PORT": 5432,
    }
}
# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
    {
        'NAME': 'core.utils.custom_auth.validators.NoSpacesPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

CORS_ALLOW_ALL_ORIGINS = True

CORS_ALLOW_CREDENTIALS = True

CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]

CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

TEST_RUNNER = 'core.utils.test_runners.CustomTestRunner'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
}

# Channel layer for Redis
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [('redis', 6379)],
        },
    },
}


REDIS_HOST = os.getenv('REDIS_HOST', 'redis')
REDIS_PORT = os.getenv('REDIS_PORT', '6379')

# Email settings
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')
EMAIL_PORT = 587
EMAIL_USE_TLS = True


MEDIA_URL = '/apps/avatars/'
MEDIA_ROOT = BASE_DIR / 'apps/avatars'"""
URL configuration for musicroom project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('deezer/', include('apps.deezer.urls')),
    path('users/', include('apps.users.urls')),
    path('tracks/', include('apps.tracks.urls')),
    path('playlists/', include('apps.playlists.urls')),
    path('devices/', include('apps.devices.urls')),
    path('auth/', include('apps.remote_auth.urls')),
    path('profile/', include('apps.profile.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
"""
WSGI config for musicroom project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_wsgi_application()
# Register your models here.
from django.apps import AppConfig


class DeezerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.deezer'
import requests

DEEZER_API_URL = "https://api.deezer.com"


class DeezerClient:
    def __init__(self):
        pass

    def get_track(self, track_id):
        """
        Get a track by its ID from Deezer.
        """
        url = f"{DEEZER_API_URL}/track/{track_id}"
        response = requests.get(url)
        return response.json() if response.status_code == 200 else None

    def get_album(self, album_id):
        """
        Get an album by its ID from Deezer.
        """
        url = f"{DEEZER_API_URL}/album/{album_id}"
        response = requests.get(url)
        return response.json() if response.status_code == 200 else None

    def get_artist(self, artist_id):
        """
        Get an artist by their ID from Deezer.
        """
        url = f"{DEEZER_API_URL}/artist/{artist_id}"
        response = requests.get(url)
        return response.json() if response.status_code == 200 else None

    def search_tracks(self, query):
        """
        Search for tracks by name or keyword.
        """
        url = f"{DEEZER_API_URL}/search"
        params = {'q': query}
        response = requests.get(url, params=params)
        return response.json() if response.status_code == 200 else None
# Create your models here.
from django.urls import path
from .views import get_deezer_track, search_deezer_tracks

urlpatterns = [
    path('track/<str:track_id>/', get_deezer_track, name='get_deezer_track'),
    path('search/', search_deezer_tracks, name='search_deezer_tracks'),
]
from django.http import JsonResponse
from .deezer_client import DeezerClient
from rest_framework.decorators import api_view
from rest_framework import status


@api_view(['GET'])
def get_deezer_track(request, track_id):
    client = DeezerClient()
    track_info = client.get_track(track_id)

    if track_info:
        return JsonResponse(track_info)
    else:
        return JsonResponse({'error': 'Track not found'}, status=404)


@api_view(['GET'])
def search_deezer_tracks(request):
    query = request.GET.get('q')
    if not query:
        return JsonResponse({"error": "Query parameter 'q' is required."}, status=status.HTTP_400_BAD_REQUEST)

    client = DeezerClient()
    results = client.search_tracks(query)

    if results is None:
        return JsonResponse({"error": "Failed to fetch data from Deezer."}, status=status.HTTP_502_BAD_GATEWAY)

    return JsonResponse(results)
from django.contrib import admin
from .models import Device, MusicControlDelegate

admin.site.register(Device)
admin.site.register(MusicControlDelegate)
from functools import wraps
from rest_framework.response import Response
from apps.devices.models import Device, MusicControlDelegate

def require_device_control(view_func):
    @wraps(view_func)
    def _wrapped_view(request, *args, **kwargs):
        user = request.user
        device_uuid = request.data.get('device_uuid') or request.query_params.get('device_uuid')

        if not device_uuid:
            return Response({'error': 'Missing device_uuid'}, status=400)

        try:
            device = Device.objects.get(uuid=device_uuid)
        except Device.DoesNotExist:
            return Response({'error': 'Device not found'}, status=404)

        is_owner = device.user == user
        is_delegate = MusicControlDelegate.objects.filter(
            owner=device.user,
            delegate=user,
            device=device,
            can_control=True
        ).exists()

        if not (is_owner or is_delegate):
            return Response({'error': 'Permission denied for this device'}, status=403)

        request.device = device

        return view_func(request, *args, **kwargs)
    return _wrapped_view
from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class Device(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    uuid = models.CharField(max_length=255, unique=True)
    license_key = models.CharField(max_length=255, unique=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.user.username}'s device ({self.uuid})"


class MusicControlDelegate(models.Model):
    owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name="delegated_from")
    delegate = models.ForeignKey(User, on_delete=models.CASCADE, related_name="delegated_to")
    device = models.ForeignKey(Device, on_delete=models.CASCADE)
    can_control = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('owner', 'delegate', 'device')

from rest_framework import serializers
from .models import Device, MusicControlDelegate
from django.contrib.auth import get_user_model

User = get_user_model()

class DeviceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Device
        fields = ['id', 'user', 'uuid', 'license_key', 'is_active']
        read_only_fields = ['id', 'user', 'is_active']


class MusicControlDelegateSerializer(serializers.ModelSerializer):
    owner = serializers.StringRelatedField(read_only=True)
    delegate = serializers.SlugRelatedField(slug_field='username', queryset=User.objects.all())
    device = serializers.SlugRelatedField(slug_field='uuid', queryset=Device.objects.all())

    class Meta:
        model = MusicControlDelegate
        fields = ['id', 'owner', 'delegate', 'device', 'can_control', 'created_at']
        read_only_fields = ['id', 'owner', 'created_at']
from django.urls import path
from .views import register_device, delegate_control, check_control_permission

urlpatterns = [
    path('register/', register_device, name='device-register'),
    path('delegate/', delegate_control, name='delegate-control'),
    path('<str:device_uuid>/can-control/', check_control_permission, name='check-control-permission'),
]
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import TokenAuthentication
from django.http import JsonResponse
from apps.devices.models import Device, MusicControlDelegate
from apps.devices.serializers import DeviceSerializer, MusicControlDelegateSerializer
from django.contrib.auth import get_user_model

User = get_user_model()

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def register_device(request):
    user = request.user
    data = request.data

    uuid = data.get("uuid")
    license_key = data.get("license_key")
    device_name = data.get("device_name", "Unnamed Device")

    if not uuid or not license_key:
        return Response({"error": "Missing uuid or license_key"}, status=400)
    try:
        device, created = Device.objects.update_or_create(
            uuid=uuid,
            defaults={
                "user": user,
                "license_key": license_key,
                "is_active": True,
            }
        )
        return JsonResponse({
            "message": "Device registered" if created else "Device updated",
            "device": DeviceSerializer(device).data
        })
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def delegate_control(request):
    user = request.user
    data = request.data

    device_uuid = data.get('device_uuid')
    delegate_user_id = data.get('delegate_user_id')
    can_control = data.get('can_control', True)

    if not device_uuid or not delegate_user_id:
        return JsonResponse({"error": "device_uuid and delegate_user_id are required"}, status=400)

    try:
        device = Device.objects.get(uuid=device_uuid, user=user)
    except Device.DoesNotExist:
        return JsonResponse({"error": "Device not found or not owned by you"}, status=404)

    try:
        delegate_user = User.objects.get(id=delegate_user_id)
    except User.DoesNotExist:
        return JsonResponse({"error": "Delegate user not found"}, status=404)

    delegation, created = MusicControlDelegate.objects.update_or_create(
        owner=user,
        delegate=delegate_user,
        device=device,
        defaults={'can_control': can_control}
    )

    serializer = MusicControlDelegateSerializer(delegation)
    return JsonResponse({
        "message": "Delegation created" if created else "Delegation updated",
        "delegation": serializer.data,
    })


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def check_control_permission(request, device_uuid):
    user = request.user

    try:
        device = Device.objects.get(uuid=device_uuid)
    except Device.DoesNotExist:
        return JsonResponse({"error": "Device not found."}, status=404)

    if device.user == user:
        return JsonResponse({"can_control": True, "reason": "User owns the device."})

    has_permission = MusicControlDelegate.objects.filter(
        owner=device.user,
        delegate=user,
        device=device,
        can_control=True
    ).exists()

    return JsonResponse({"can_control": has_permission})
from django.contrib import admin

from .models import Playlist, PlaylistTrack
from apps.tracks.models import Track

class PlaylistTrackInline(admin.TabularInline):
    model = PlaylistTrack
    extra = 1
    ordering = ['position']
    readonly_fields = ['position']
    autocomplete_fields = ['track']
    fields = ['playlist', 'track', 'position']
    show_change_link = True

    def track_display(self, obj):
        return f"{obj.track.name} â€“ {obj.track.artist}"
    track_display.short_description = "Track"

class PlaylistAdmin(admin.ModelAdmin):
    list_display = ['name', 'id']
    inlines = [PlaylistTrackInline]

class PlaylistTrackAdmin(admin.ModelAdmin):
    list_display = ['playlist', 'position', 'track_name', 'track_artist']
    ordering = ['playlist', 'position']
    list_filter = ['playlist']
    search_fields = ['track__name', 'track__artist']

    def track_name(self, obj):
        return obj.track.name

    def track_artist(self, obj):
        return obj.track.artist

admin.site.register(Playlist, PlaylistAdmin)
admin.site.register(PlaylistTrack, PlaylistTrackAdmin)
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.playlists'
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class PlaylistConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.playlist_id = self.scope['url_route']['kwargs']['playlist_id']
        self.group_name = f'playlist_{self.playlist_id}'
        print(f"WebSocket connected to playlist {self.playlist_id}")
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        await self.accept()

    async def disconnect(self, close_code):
        print(f"WebSocket disconnected {close_code}")
        await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def playlist_update(self, event):
        print(f"Sending playlist update to the client: {event}")
        await self.send(text_data=json.dumps({
            'playlist_id': event['playlist_id'],
            'type': 'playlist_update',
            'data': event['data'],
        }))
from functools import wraps
from rest_framework.response import Response
from apps.playlists.models import Playlist


def check_access_to_playlist(view_func):
    @wraps(view_func)
    def _wrapped_view(request, *args, **kwargs):
        user = request.user
        playlist_id = kwargs.get('playlist_id')
        print('check_access_to_playlist')
        if not playlist_id:
            return Response({'error': 'Missing playlist id'}, status=400)

        try:
            playlist = Playlist.objects.get(id=playlist_id)
        except Playlist.DoesNotExist:
            return Response({'error': 'Playlist not found'}, status=404)
        print(playlist.public)
        if user not in playlist.users_saved.all() and not playlist.public:
            return Response({'error': 'Permission denied for this playlist'}, status=403)

        return view_func(request, *args, **kwargs)
    return _wrapped_view
from django.db import models
from django.contrib.auth import get_user_model
from apps.tracks.models import Track

User = get_user_model()


class Playlist(models.Model):

    creator = models.ForeignKey(User, on_delete=models.CASCADE, related_name="playlists")
    name = models.CharField(max_length=255)
    description = models.TextField()
    public = models.BooleanField(default=True)
    #tracks = models.ManyToManyField(Track, related_name='playlists')
    users_saved = models.ManyToManyField(User, related_name='saved_playlists', blank=True)

    def __str__(self):
        return self.name

class PlaylistTrack(models.Model):
    playlist = models.ForeignKey(Playlist, on_delete=models.CASCADE, related_name='tracks')
    track = models.ForeignKey(Track, on_delete=models.CASCADE)
    position = models.PositiveIntegerField()

    class Meta:
        unique_together = ('playlist', 'position')
        ordering = ['position']


    def save(self, *args, **kwargs):
        if not self.position:
            # Automatically set position to the next available integer
            self.position = PlaylistTrack.objects.filter(playlist=self.playlist).count()
        super().save(*args, **kwargs)
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'^ws/playlists/(?P<playlist_id>\d+)/$', consumers.PlaylistConsumer.as_asgi()),
]
from django.urls import path
from . import views

urlpatterns = [
    path('playlists', views.create_new_playlist, name='playlists'),
    path('playlists/<int:playlist_id>', views.get_playlist_info, name='get_playlist'), 
    path('playlists/<int:playlist_id>/remove_tracks', views.delete_track_from_playlist, name='remove_items'),
    # do not need ?
    #path('save_playlist/', views.save_shared_playlist, name='save_playlist'),
    path('saved_playlists/', views.get_user_saved_playlists, name='saved_playlists'),
    path('public_playlists/', views.get_all_shared_playlists, name='public_playlists'),
    path('playlist/<int:playlist_id>/tracks/', views.playlist_tracks),
    path('<int:playlist_id>/add/', views.add_track),
    path('<int:playlist_id>/move-track/', views.move_track_in_playlist),
    path('<int:playlist_id>/change-visibility/', views.change_visibility),
    path('<int:playlist_id>/invite-user/', views.invite_user),
]
import json
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from django.http import JsonResponse
from .models import Playlist, Track
from apps.tracks.models import Track
from apps.users.models import User
from django.shortcuts import get_object_or_404
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated
from apps.playlists.models import Playlist, PlaylistTrack
from django.db import models
from django.db import transaction
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.forms.models import model_to_dict
from .decorators import check_access_to_playlist
from apps.devices.decorators import require_device_control


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def create_new_playlist(request):
    user = request.user
    name = request.data.get('name')
    description = request.data.get('description', '')
    public = request.data.get('public', True)
    public = True
    if not name:
        return JsonResponse({"error": "Playlist name is required."}, status=400)
    playlist = Playlist.objects.create(
        name=name,
        description=description,
        public=public,
        creator=user
    )
    user.saved_playlists.add(playlist)

    return JsonResponse({
        "message": "Empty playlist is created.",
        "playlist_id": playlist.id
    }, status=201)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def get_user_saved_playlists(request):
    user = request.user

    playlists = Playlist.objects.filter(users_saved=user)

    playlist_data = []
    for playlist in playlists:
        tracks = playlist.tracks.all()
        track_list = [{'name': pt.track.name, 'artist': pt.track.artist} for pt in tracks]

        playlist_data.append({
            'id': playlist.id,
            'name': playlist.name,
            'description': playlist.description,
            'public': playlist.public,
            'creator': playlist.creator.username,
            'tracks': track_list,
        })

    return JsonResponse({'playlists': playlist_data})


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def get_all_shared_playlists(request):

    playlists = Playlist.objects.filter(public=True)

    playlist_data = []
    for playlist in playlists:
        tracks = playlist.tracks.all()
        track_list = [{'name': pt.track.name, 'artist': pt.track.artist} for pt in tracks]

        playlist_data.append({
            'id': playlist.id,
            'name': playlist.name,
            'description': playlist.description,
            'public': playlist.public,
            'creator': playlist.creator.username,  # Show the creator of the playlist
            'tracks': track_list,
        })

    return JsonResponse({'playlists': playlist_data})


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def save_shared_playlist(request):
    if not request.user.is_authenticated:
        return JsonResponse({"error": "Authentication required."}, status=401)

    user = request.user
    name = request.data.get('name')
    description = request.data.get('description', '')
    public = request.data.get('public', False)
    track_ids = request.data.get('track_ids', [])  # List of track IDs to associate with the playlist

    if not name:
        return JsonResponse({"error": "Playlist name is required."}, status=400)

    playlist = Playlist.objects.create(
        name=name,
        description=description,
        public=public,
        creator=user
    )

    tracks = Track.objects.filter(id__in=track_ids)

    if tracks.exists():
        playlist.tracks.add(*tracks)
    else:
        return JsonResponse({"error": "One or more tracks not found."}, status=404)

    user.saved_playlists.add(playlist)

    return JsonResponse({
        "message": "Playlist created and tracks added successfully.",
        "playlist_id": playlist.id,
        "tracks": [track.id for track in tracks]
    }, status=201)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def get_playlist_info(request, playlist_id):
    try:
        user = request.user
        playlist = get_object_or_404(Playlist, id=playlist_id)


        playlist_data = []
        tracks = playlist.tracks.all()
        track_list = [{'name': pt.track.name, 'artist': pt.track.artist} for pt in tracks]

        playlist_data.append({
            'id': playlist.id,
            'playlist_name': playlist.name,
            'description': playlist.description,
            'public': playlist.public,
            'creator': playlist.creator.username,
            'tracks': track_list,
        })

        return JsonResponse({'playlist': playlist_data})
    except Playlist.DoesNotExist:
        return JsonResponse({"error": "Playlist not found."}, status=404)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
#@require_device_control
def playlist_tracks(request, playlist_id):
    playlist = get_object_or_404(Playlist, id=playlist_id)
    tracks = PlaylistTrack.objects.filter(playlist=playlist).select_related('track')

    data = [{
        'track_id': pt.track.id,
        'name': pt.track.name,
        'position': pt.position,
    } for pt in tracks]

    return JsonResponse({'playlist': playlist.name, 'tracks': data})

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
@check_access_to_playlist
#@require_device_control
def add_track(request, playlist_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Invalid method'}, status=405)
    try:
        print('add_track starts')
        playlist = get_object_or_404(Playlist, id=playlist_id)
        #data = json.loads(request.body)
        data = request.data

        track_id = data.get("track_id")
        track = get_object_or_404(Track, id=track_id)

        max_pos = PlaylistTrack.objects.filter(playlist=playlist).aggregate(models.Max('position'))['position__max'] or 0
        PlaylistTrack.objects.create(playlist=playlist, track=track, position=max_pos + 1)
        tracks = list(PlaylistTrack.objects.filter(playlist=playlist).order_by('position'))
        # Broadcast
        data = [{"id": t.id, "track": model_to_dict(t.track),"position": t.position} for t in tracks] 
        channel_layer = get_channel_layer()
        print(channel_layer)
        async_to_sync(channel_layer.group_send)(
            f'playlist_{playlist_id}',
            {
                'type': 'playlist.update',
                'playlist_id': playlist_id,
                'data': data,
            }
        )
        return JsonResponse({'status': 'track added'}, status=201)
    except Playlist.DoesNotExist:
        return JsonResponse({'error': 'Playlist not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
@check_access_to_playlist
#@require_device_control
def move_track_in_playlist(request, playlist_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Invalid method'}, status=405)

    try:
        print('move_track_in_playlist starts')
        data = json.loads(request.body)
        range_start = data['range_start']
        insert_before = data['insert_before']
        range_length = data.get('range_length', 1)
        playlist = Playlist.objects.get(id=playlist_id)
        tracks = list(PlaylistTrack.objects.filter(playlist=playlist).order_by('position'))
        moving_slice = tracks[range_start:range_start + range_length]
        if not moving_slice:
            return JsonResponse({'error': 'Invalid range'}, status=400)

        del tracks[range_start:range_start + range_length]

        if insert_before > range_start:
            insert_before -= range_length

        for i, track in enumerate(moving_slice):
            tracks.insert(insert_before + i, track)

        TEMP_OFFSET = 1000
        with transaction.atomic():
            for i, pt in enumerate(tracks):
                pt.position = i + TEMP_OFFSET
            PlaylistTrack.objects.bulk_update(tracks, ['position'])

            for i, pt in enumerate(tracks):
                pt.position = i
            PlaylistTrack.objects.bulk_update(tracks, ['position'])
        # Broadcast
        data = [{"id": t.id, "track": model_to_dict(t.track),"position": t.position} for t in tracks]   
        channel_layer = get_channel_layer()
        print(channel_layer)
        async_to_sync(channel_layer.group_send)(
            f'playlist_{playlist_id}',
            {
                'type': 'playlist.update',
                'playlist_id': playlist_id,
                'data': data,
            }
        )
        return JsonResponse({'message': 'Tracks reordered successfully'})

    except Playlist.DoesNotExist:
        return JsonResponse({'error': 'Playlist not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
@check_access_to_playlist
#@require_device_control
def delete_track_from_playlist(request, playlist_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Invalid method'}, status=405)

    try:
        print('delete_track_from_playlist starts')
        data = json.loads(request.body)

        track_id = data['track_id']
        playlist = Playlist.objects.get(id=playlist_id)
        track_to_delete = PlaylistTrack.objects.get(playlist=playlist, id=track_id)
        print(track_to_delete.id)
        with transaction.atomic():
            track_to_delete.delete()

            # Reorder
            remaining_tracks = list(PlaylistTrack.objects.filter(playlist=playlist).order_by('position'))

            TEMP_OFFSET = 1000
            for i, pt in enumerate(remaining_tracks):
                pt.position = i + TEMP_OFFSET
            PlaylistTrack.objects.bulk_update(remaining_tracks, ['position'])

            for i, pt in enumerate(remaining_tracks):
                pt.position = i
            PlaylistTrack.objects.bulk_update(remaining_tracks, ['position'])

        # Broadcast
        tracks = list(PlaylistTrack.objects.filter(playlist=playlist).order_by('position'))
        data = [{"id": t.id, "track": model_to_dict(t.track),"position": t.position} for t in tracks] 
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'playlist_{playlist_id}',
            {
                'type': 'playlist.update',
                'playlist_id': playlist_id,
                'data': data,
            }
        )

        return JsonResponse({'message': 'Track deleted successfully'})

    except Playlist.DoesNotExist:
        return JsonResponse({'error': 'Playlist not found'}, status=404)
    except PlaylistTrack.DoesNotExist:
        return JsonResponse({'error': 'Track not found in playlist'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def change_visibility(request, playlist_id):
    try:
        public = request.data.get('public', True)
        #lets set True for now
        public = True
        playlist = Playlist.objects.get(id=playlist_id)
        playlist.public = public
        playlist.save()
        print(playlist.users_saved.all())
        return JsonResponse({'message': 'Playlist visibility changed successfully'})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)    

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
@check_access_to_playlist
def invite_user(request, playlist_id):
    try:
        
        user_id=request.data.get('user_id')
        playlist = Playlist.objects.get(id=playlist_id)
        print(playlist.users_saved.all())
        user_to_invite = User.objects.get(id=user_id)
        if user_to_invite in playlist.users_saved.all():
            return JsonResponse({'message': 'User already invited'}, status=200)
        playlist.users_saved.add(user_to_invite)
        print(playlist.users_saved.all())
        return JsonResponse({'message': 'User invited to the playlist'}, status=201)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400) 
# Register your models here.

from django.contrib import admin

from .models import ProfilePublic
from .models import ProfilePrivate
from .models import ProfileFriend
from .models import ProfileMusic

admin.site.register(ProfilePublic)
admin.site.register(ProfilePrivate)
admin.site.register(ProfileFriend)
admin.site.register(ProfileMusic)
from django.apps import AppConfig


class AuthConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.profile'
from django.db import models
from django.contrib.auth.models import User
from django.contrib.postgres.fields import ArrayField


class ProfilePublic(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile_public')

    gender = models.CharField(
        max_length=6,
        choices=[('female', 'female'), ('male', 'male')],
        null=True,
        blank=True
        )
    
    avatar = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        default=''
        )
    
    location = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        default=''
        )
    
    bio = models.CharField(
        max_length=500,
        null=True,
        blank=True,
        default=''
        )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "User Public Info"
        verbose_name_plural = "User Public Infos"
        
    def __str__(self):
        return (
            f"user id: {self.user.id}, gender: {self.gender}, avatar: {self.avatar},"
            f"location: {self.location}, bio: {self.bio}"
            )


class ProfilePrivate(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile_private')

    first_name = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        default=''
        )
    
    last_name = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        default=''
        )

    phone = models.CharField(
        max_length=10,
        null=True,
        blank=True,
        default=''
        )
    
    street = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        default=''
        )
    
    country = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        default=''
        )
    
    postal_code = models.CharField(
        max_length=10,
        null=True,
        blank=True,
        default=''
        )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "User Private Info"
        verbose_name_plural = "User Private Infos"
        
    def __str__(self):
        return (
            f"user id: {self.user.id}, first_name: {self.first_name}, last_name: {self.last_name},"
            f"phone: {self.phone}, street: {self.street}, country: {self.country}, postal_code: {self.postal_code}"
            )


class ProfileFriend(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile_friend')

    dob = models.DateField(
        null=True, 
        blank=True
    )
    
    hobbies = ArrayField(
        models.CharField(max_length=50),
        blank=True,
        default=list
    )

    friend_info = models.CharField(
        max_length=500,
        null=True,
        blank=True,
        default=''
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "User Friend Info"
        verbose_name_plural = "User Friend Infos"
        
    def __str__(self):
        return (
            f"user id: {self.user.id}, dob: {self.dob}, hobbies: {self.hobbies}, friend_info: {self.friend_info}"
        )


class ProfileMusic(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile_music')
    
    music_preferences = ArrayField(
        models.CharField(max_length=50),
        blank=True,
        default=list
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "User Music Preference"
        verbose_name_plural = "User Music Preferences"
        
    def __str__(self):
        return (
            f"user id: {self.user.id}, music_preferences: {self.music_preferences}"
        )from django.urls import path
from . import views
from django.conf import settings

urlpatterns = [
    path('public/', views.public_info, name='public_info'),
    path('friend/', views.friend_info, name='friend_info'),
    path('private/', views.private_info, name='private_info'),
    path('music/', views.music_preferences, name='music_preferences'),
    path('public/update/', views.update_public_info, name='update_public_info'),
    path('friend/update/', views.update_friend_info, name='update_friend_info'),
    path('private/update/', views.update_private_info, name='update_private_info'),
    path('music/update/', views.update_music_preferences, name='update_music_pref'),

]import os
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from django.http import JsonResponse
from rest_framework import status
from django.contrib.auth import get_user_model
import requests
from rest_framework.response import Response
from rest_framework.authtoken.models import Token
from .models import ProfilePublic
from .models import ProfilePrivate
from .models import ProfileFriend
from .models import ProfileMusic
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated
from django.conf import settings
import base64
import uuid
from urllib.parse import urljoin


User = get_user_model()


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def update_public_info(request):
    user = request.user
    avatar_base64 = request.data.get('avatarBase64')
    mime_type = request.data.get('mimeType')
    gender = request.data.get('gender')
    location = request.data.get('location')
    bio = request.data.get('bio')
    
    try:
        profile_public = ProfilePublic.objects.filter(user=user).first()
        if not profile_public:
            profile_public = ProfilePublic.objects.create(
                user = user,
            )
        if mime_type and avatar_base64:
            ext = '.' + mime_type.split('/')[1]
            filename = uuid.uuid4().hex + ext
            file_data = base64.b64decode(avatar_base64)
            save_dir = os.path.join(settings.MEDIA_ROOT)
            file_path = os.path.join(save_dir, filename)
            with open(file_path, 'wb') as f:
                f.write(file_data)
            media_url = urljoin(settings.MEDIA_URL, filename)
            if file_path:
                profile_public.avatar = media_url

        if gender:
            profile_public.gender = gender
        
        if location:
            profile_public.location = location
        
        if bio:
            profile_public.bio = bio
        
        profile_public.save()

        data = {
            'avatar': profile_public.avatar,
            'gender': profile_public.gender,
            'location': profile_public.location,
            'bio': profile_public.bio,
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def public_info(request):
    user = request.user
    try:
        profile_public = ProfilePublic.objects.filter(user=user).first()
        if not profile_public:
            profile_public = ProfilePublic.objects.create(
                user = user,
            )
        data = {
            'avatar': profile_public.avatar,
            'gender': profile_public.gender,
            'location': profile_public.location,
            'bio': profile_public.bio,   
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def update_private_info(request):
    user = request.user
    first_name = request.data.get('firstName')
    last_name = request.data.get('lastName')
    phone = request.data.get('phone')
    street = request.data.get('street')
    country = request.data.get('country')
    postal_code = request.data.get('postalCode')
    
    try:
        profile_private = ProfilePrivate.objects.filter(user=user).first()
        if not profile_private:
            profile_private = ProfilePrivate.objects.create(
                user = user,
            )
    
        if first_name:
            profile_private.first_name = first_name
        
        if last_name:
            profile_private.last_name = last_name

        if phone:
            profile_private.phone = phone
        
        if street:
            profile_private.street = street
        
        if country:
            profile_private.country = country
        
        if postal_code:
            profile_private.postal_code = postal_code
        
        profile_private.save()

        data = {
            'first_name': profile_private.first_name,
            'last_name': profile_private.last_name,
            'phone': profile_private.phone,
            'street': profile_private.street,
            'country': profile_private.country,
            'postal_code': profile_private.postal_code
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def private_info(request):
    user = request.user
    try:
        profile_private = ProfilePrivate.objects.filter(user=user).first()
        if not profile_private:
            profile_private = ProfilePrivate.objects.create(
                user = user,
            )
        data = {
            'first_name': profile_private.first_name,
            'last_name': profile_private.last_name,
            'phone': profile_private.phone,
            'street': profile_private.street,
            'country': profile_private.country,
            'postal_code': profile_private.postal_code
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def update_friend_info(request):
    user = request.user
    dob = request.data.get('dob')
    hobbies = request.data.get('hobbies', [])
    friend_info = request.data.get('friendInfo')
    
    try:
        profile_friend = ProfileFriend.objects.filter(user=user).first()
        if not profile_friend:
            profile_friend = ProfileFriend.objects.create(
                user = user,
            )
    
        if dob:
            profile_friend.dob = dob
        
        if hobbies:
            profile_friend.hobbies = hobbies

        if friend_info:
            profile_friend.friend_info = friend_info
        
        profile_friend.save()

        data = {
            'dob': profile_friend.dob,
            'hobbies': profile_friend.hobbies,
            'friend_info': profile_friend.friend_info
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def friend_info(request):
    user = request.user
    try:
        profile_friend = ProfileFriend.objects.filter(user=user).first()
        if not profile_friend:
            profile_friend = ProfileFriend.objects.create(
                user = user,
            )
        data = {
            'dob': profile_friend.dob,
            'hobbies': profile_friend.hobbies,
            'friend_info': profile_friend.friend_info
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def update_music_preferences(request):
    user = request.user
    music_preferences = request.data.get('musicPreferences', [])
    
    try:
        profile_music = ProfileMusic.objects.filter(user=user).first()
        if not profile_music:
            profile_music = ProfileMusic.objects.create(
                user = user,
            )
        
        if music_preferences:
            profile_music.music_preferences = music_preferences
        
        profile_music.save()

        data = {
            'music_preferences': profile_music.music_preferences,
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def music_preferences(request):
    user = request.user
    try:
        profile_music = ProfileMusic.objects.filter(user=user).first()
        if not profile_music:
            profile_music = ProfileMusic.objects.create(
                user = user,
            )
        data = {
            'music_preferences': profile_music.music_preferences,
        }
        return JsonResponse(data, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)# Register your models here.

from django.contrib import admin

from .models import SocialNetwork

admin.site.register(SocialNetwork)from django.apps import AppConfig


class AuthConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.remote_auth'
from django.db import models
from django.conf import settings
from django.contrib.auth.models import User
from django.core.validators import EmailValidator


class SocialNetwork(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    type = models.CharField(
        max_length=8,
        choices=[('facebook', 'Facebook'), ('google', 'Google')]
        )
    
    social_id = models.CharField(
        max_length=32,
        unique=True,
        null=False,
        blank=False
        )
    
    name = models.CharField(
        max_length=150,
        blank=True,
        null=False,
        default=''
        )
    
    email = models.EmailField(
        max_length=255,
        blank=True,
        null=False,
        unique=True,
        validators=[EmailValidator()],
        error_messages={
            'error': 'This email address is already registered.'
        }
        )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Social Network Account"
        verbose_name_plural = "Social Network Accounts"
        unique_together = [('type', 'social_id')]

    def __str__(self):
        return (
            f"user id: {self.user.id}, username: {self.user.username}, user email: {self.user.email}," 
            f"social id: {self.social_id}, name: {self.name}, social email: {self.email}"
            )

from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
import re

User = get_user_model()


class NoStripCharField(serializers.CharField):
    def to_internal_value(self, data):
        return data


class RemoteUserSerializer(serializers.ModelSerializer):
    username = NoStripCharField(required=True, min_length=1, max_length=150)
    email = NoStripCharField(required=True)

    class Meta:
        model = User
        fields = ['id', 'username', 'email']

    def validate_username(self, value):
        if value != value.strip():
            raise serializers.ValidationError("Username cannot have leading or trailing spaces.")

        if not re.match(r'^\w+$', value):
            raise serializers.ValidationError("Username can only contain letters, numbers, and underscores.")

        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError("Username is already taken.")

        return value

    def validate_email(self, value):
        if value != value.strip():
            raise serializers.ValidationError("Email cannot have leading or trailing spaces.")

        email_regex = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
        if not re.match(email_regex, value):
            raise serializers.ValidationError("Enter a valid email address.")

        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("Email is already taken.")

        return value

    def create(self, validated_data):
        user = User.objects.create(**validated_data)
        user.set_unusable_password()
        user.save()
        return user

from django.urls import path
from . import views

urlpatterns = [
    path('facebook/login/', views.facebook_login, name='facebook_login'),
    path('google/login/', views.google_login, name='google_login'),
    path('facebook/link/', views.facebook_link, name='facebook_link'),
    path('google/link/', views.google_link, name='google_link'),
]
import os
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from django.http import JsonResponse
from rest_framework.decorators import api_view
from rest_framework import status
from django.contrib.auth import get_user_model
import requests
from rest_framework.response import Response
from rest_framework.authtoken.models import Token
from apps.users.serializers import UserSerializer
from django.shortcuts import get_object_or_404
from django.http import Http404
from django.utils import timezone
from google.oauth2 import id_token as google_id_token
from google.auth.transport import requests as google_requests
from .models import SocialNetwork
from .serializers import RemoteUserSerializer
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated

User = get_user_model()

FACEBOOK_APP_ID = os.environ.get('FACEBOOK_APP_ID')
FACEBOOK_APP_SECRET = os.environ.get('FACEBOOK_APP_SECRET')
GOOGLE_CLIENT_ID_WEB = os.environ.get('GOOGLE_CLIENT_ID_WEB')
GOOGLE_CLIENT_ID_APP = os.environ.get('GOOGLE_CLIENT_ID_APP')


@api_view(['POST'])
def facebook_login(request):

    fb_access_token = request.data.get('fbAccessToken')

    if not fb_access_token:
        return JsonResponse({'error': 'Access token not provided'}, status=status.HTTP_400_BAD_REQUEST)

    verify_access_token_url = f'https://graph.facebook.com/debug_token?input_token={fb_access_token}&access_token={FACEBOOK_APP_ID}|{FACEBOOK_APP_SECRET}'
    veriify_response = requests.get(verify_access_token_url).json()

    if not veriify_response.get('data', {}).get('is_valid'):
        return JsonResponse({'error': 'Invalid Facebook access token'}, status=status.HTTP_400_BAD_REQUEST)

    user_id = veriify_response['data']['user_id']

    user_info_url = f'https://graph.facebook.com/{user_id}?fields=id,name,email&access_token={fb_access_token}'
    user_info = requests.get(user_info_url).json()

    email = user_info.get('email')
    username = user_info.get('name') or email.split('@')[0]
    username = username.replace(' ', '_')
    social_id = user_info.get('id');

    if not email:
        return JsonResponse({'error': 'Invalid login credentials'}, status=status.HTTP_400_BAD_REQUEST)
    
    return social_login(email, username, social_id, 'facebook')


@api_view(['POST'])
def google_login(request):
    id_token = request.data.get('idToken')
    type = request.data.get('type')
    
    if not id_token:
        return JsonResponse({'error': 'idToken token not provided'}, status=status.HTTP_400_BAD_REQUEST)
    if not type:
        return JsonResponse({'error': 'type not provided'}, status=status.HTTP_400_BAD_REQUEST)

    if type == 'web':
        google_client_id = GOOGLE_CLIENT_ID_WEB
    if type == 'app':
        google_client_id = GOOGLE_CLIENT_ID_APP
    
    try:
        id_info = google_id_token.verify_oauth2_token(id_token, google_requests.Request(), google_client_id)
    except ValueError:
        return JsonResponse({'error': 'Invalid idToken'}, status=status.HTTP_400_BAD_REQUEST)

    email = id_info.get('email')
    username = id_info.get('name') or id_info.get('email').split('@')[0]
    username = username.replace(' ', '_')
    social_id = id_info.get('sub')

    if not email:
            return JsonResponse({'error': 'Invalid login credentials'}, status=status.HTTP_400_BAD_REQUEST)

    return social_login(email, username, social_id, 'google')


def social_login(email, username, social_id, type):

    user_data = {
        'username': username,
        'email': email
    }

    social = SocialNetwork.objects.filter(social_id=social_id).first()

    if not social:
        user = User.objects.filter(email=email).first()
        if not user:
            serializer = RemoteUserSerializer(data=user_data)
            if serializer.is_valid():
                user = serializer.save()
                token = Token.objects.create(user=user)
                response_data = {
                    'token': token.key,
                    'user': serializer.data
                }
                SocialNetwork.objects.create(
                    user = user,
                    type = type,
                    social_id = social_id,
                    name = username,
                    email = email
                )
                return JsonResponse(response_data, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'error': 'Already has a account with same email.'}, status=status.HTTP_400_BAD_REQUEST)
    
    if social:
        user = social.user
        token, created = Token.objects.get_or_create(user=user)
        user.last_activity = timezone.now()
        user.save()
        response_data = {
            'token': token.key,
            'user': {
                'username': user.username,
                'id': user.id
            }
        }
        return JsonResponse(response_data, status=status.HTTP_200_OK)     


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def facebook_link(request):

    fb_access_token = request.data.get('fbAccessToken')
    user = request.user

    if not fb_access_token:
        return JsonResponse({'error': 'Access token not provided'}, status=status.HTTP_400_BAD_REQUEST)

    verify_access_token_url = f'https://graph.facebook.com/debug_token?input_token={fb_access_token}&access_token={FACEBOOK_APP_ID}|{FACEBOOK_APP_SECRET}'
    veriify_response = requests.get(verify_access_token_url).json()

    if not veriify_response.get('data', {}).get('is_valid'):
        return JsonResponse({'error': 'Invalid Facebook access token'}, status=status.HTTP_400_BAD_REQUEST)

    user_id = veriify_response['data']['user_id']

    user_info_url = f'https://graph.facebook.com/{user_id}?fields=id,name,email&access_token={fb_access_token}'
    user_info = requests.get(user_info_url).json()

    email = user_info.get('email')
    username = user_info.get('name') or email.split('@')[0]
    username = username.replace(' ', '_')
    social_id = user_info.get('id');

    if not email:
        return JsonResponse({'error': 'Invalid login credentials'}, status=status.HTTP_400_BAD_REQUEST)

    return social_link(user, email, username, social_id, 'facebook')


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def google_link(request):
    id_token = request.data.get('idToken')
    type = request.data.get('type')
    user = request.user

    if not id_token:
        return JsonResponse({'error': 'idToken token not provided'}, status=status.HTTP_400_BAD_REQUEST)

    if type == 'web':
        google_client_id = GOOGLE_CLIENT_ID_WEB
    if type == 'app':
        google_client_id = GOOGLE_CLIENT_ID_APP

    try:
        id_info = google_id_token.verify_oauth2_token(id_token, google_requests.Request(), google_client_id)
    except ValueError:
        return JsonResponse({'error': 'Invalid idToken'}, status=status.HTTP_400_BAD_REQUEST)

    email = id_info.get('email')
    username = id_info.get('name') or id_info.get('email').split('@')[0]
    username = username.replace(' ', '_')
    social_id = id_info.get('sub')

    if not email:
            return JsonResponse({'error': 'Invalid login credentials'}, status=status.HTTP_400_BAD_REQUEST)

    return social_link(user, email, username, social_id, 'google')


def social_link(user, email, username, social_id, type):

    user_email = User.objects.filter(email=email).first()
    if user_email:
        if user_email.id != user.id:
            return JsonResponse({'error': 'Email use by other user'}, status=status.HTTP_400_BAD_REQUEST)

    social = SocialNetwork.objects.filter(user=user).first()
    if not social:
        social_email = SocialNetwork.objects.filter(email=email).first()
        social_social_id = SocialNetwork.objects.filter(social_id=social_id).first()
        if not social_email and not social_social_id:
            SocialNetwork.objects.create(
                user = user,
                type = type,
                social_id = social_id,
                name = username,
                email = email
            )
            return JsonResponse({'id': user.id}, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'error': 'Email or Social network already in use'}, status=status.HTTP_400_BAD_REQUEST)
    else:
        return JsonResponse({'error': 'Social network already linked'}, status=status.HTTP_400_BAD_REQUEST)from django.contrib import admin
from .models import Track

class TrackAdmin(admin.ModelAdmin):
    list_display = ['name', 'artist']
    search_fields = ['name', 'artist']

admin.site.register(Track, TrackAdmin)
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.tracks'
# ================================
# akolgano
# ================================

from django.db import models


class Track(models.Model):
    name = models.CharField(max_length=255)
    artist = models.CharField(max_length=255)
    deezer_track_id = models.CharField(max_length=255, unique=True, default=0)
    album = models.CharField(max_length=255, blank=True, null=True)
    url = models.URLField(default='')

    def __str__(self):
        return f"{self.name} by {self.artist}"
from django.urls import path
from . import views

urlpatterns = [
    path('search/', views.search_tracks, name='search_tracks'),
    path('add_from_deezer/<int:track_id>/', views.add_track_from_deezer, name='add_track_from_deezer'),
]
from .models import Track
import requests
from django.http import JsonResponse
from apps.deezer.deezer_client import DeezerClient
from django.views.decorators.csrf import csrf_exempt


def get_deezer_tracks(query):
    """
    Fetch tracks from Deezer API based on a search query.
    """
    url = f"http://127.0.0.1:8000/deezer/search/?q={query}"
    response = requests.get(url)

    if response.status_code == 200:
        tracks = response.json().get('data', [])
        return tracks
    else:
        return None


def search_tracks(request):
    query = request.GET.get('query', '')
    tracks = []

    if query:
        tracks_data = get_deezer_tracks(query)

        if tracks_data:
            for track_data in tracks_data:
                Track.objects.update_or_create(
                    deezer_track_id=track_data['id'],
                    defaults={
                        'name': track_data['title'],
                        'artist': track_data['artist']['name'],
                        'album': track_data['album']['title'],
                        'url': track_data['link'],
                    }
                )

            tracks = Track.objects.filter(name__icontains=query)
        else:
            tracks = []

    return JsonResponse({'tracks': list(tracks.values())})


@csrf_exempt
def add_track_from_deezer(request, track_id):

    client = DeezerClient()
    track_data = client.get_track(track_id)
    if not track_data:
        return JsonResponse({"error": "Track not found on Deezer."}, status=404)

    track, created = Track.objects.get_or_create(
        name=track_data['title'],
        artist=track_data['artist']['name'],
        album=track_data['album']['title'],
        deezer_track_id=track_data['id'],
        url=track_data['link']
    )

    if created:
        return JsonResponse({"message": "Track added successfully."}, status=201)
    else:
        return JsonResponse({"message": "Track already exists."}, status=200)
# Register your models here.

from django.contrib import admin

from .models import Friendship

admin.site.register(Friendship)from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.users'
from django.core.mail import EmailMultiAlternatives
import os


def send_forgot_password_email(otp, email, username):
    subject = 'OTP for reset password'
    text_content = f'User Name: {username}. Your OTP to reset password is {otp}. Expired in 5 minutes.'
    html_content = f'<p>User Name: {username}</p><p>Your OTP to reset password is <strong>{otp}</strong>. Expired in 5 minutes.</p>'

    msg = EmailMultiAlternatives(subject, text_content, os.environ.get('EMAIL_HOST_USER'), [email])
    msg.attach_alternative(html_content, "text/html")
    msg.send()

def send_signup_otp_email(otp, email):
    subject = 'OTP for Email verification'
    text_content = f'Your OTP to verify email is {otp}. Expired in 5 minutes.'
    html_content = f'<p>Your OTP to verify email is <strong>{otp}</strong>. Expired in 5 minutes.</p>'

    msg = EmailMultiAlternatives(subject, text_content, os.environ.get('EMAIL_HOST_USER'), [email])
    msg.attach_alternative(html_content, "text/html")
    msg.send()from django.db import models 
from django.conf import settings
from django.contrib.auth.models import User
from django.contrib.auth.models import AbstractUser
from django.utils import timezone
from datetime import timedelta

class Friendship(models.Model):
    from_user = models.ForeignKey(User, related_name='friendships_created', on_delete=models.CASCADE)
    to_user = models.ForeignKey(User, related_name='friendships_received', on_delete=models.CASCADE)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    status = models.CharField(
        max_length=10,
        choices=[('pending', 'Pending'), ('accepted', 'Accepted')],
        default='pending'
    )
    class Meta:
        unique_together = ('from_user', 'to_user')
        verbose_name = 'Friendship'
        verbose_name_plural = 'Friendships'

    def __str__(self):
        return f"{self.from_user} -> {self.to_user}"


def get_expiry_time():
    return timezone.now() + timedelta(minutes=5)

class OneTimePasscode(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    code = models.IntegerField()
    expired_at = models.DateTimeField(default=get_expiry_time)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"OTP code for {self.user.email} (expires at {self.expired_at})"

class SignupOneTimePasscode(models.Model):
    email = models.EmailField(unique=True)
    code = models.IntegerField()
    expired_at = models.DateTimeField(default=get_expiry_time)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"OTP code for {self.email} (expires at {self.expired_at})"
# ================================
# akolgano
# ================================


from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
import re
User = get_user_model()


class NoStripCharField(serializers.CharField):
    def to_internal_value(self, data):
        return data


class UserSerializer(serializers.ModelSerializer):
    username = NoStripCharField(required=True, min_length=1, max_length=20)
    email = NoStripCharField(required=True)
    password = NoStripCharField(write_only=True, required=True, min_length=8)

    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'password']

    def validate_username(self, value):
        if value != value.strip():
            raise serializers.ValidationError("Username cannot have leading or trailing spaces.")

        if not re.match(r'^\w+$', value):
            raise serializers.ValidationError("Username can only contain letters, numbers, and underscores.")

        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError("Username is already taken.")

        return value

    def validate_email(self, value):
        if value != value.strip():
            raise serializers.ValidationError("Email cannot have leading or trailing spaces.")

        email_regex = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
        if not re.match(email_regex, value):
            raise serializers.ValidationError("Enter a valid email address.")

        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("Email is already taken.")

        return value

    def validate_password(self, value):
        try:
            validate_password(value)
        except ValidationError as e:
            raise serializers.ValidationError(e.messages)
        return value

    def create(self, validated_data):
        password = validated_data.pop('password')
        user = User.objects.create(**validated_data)
        user.set_password(password)
        user.save()
        return user



class FriendSerializer(serializers.ModelSerializer):

    class Meta:
        model = User
        fields = ['username']
from django.urls import path
from . import views

app_name = "users"

urlpatterns = [
    path('signup/', views.signup, name='signup'),
    path('login/', views.login_view, name='login'),
    path('logout/', views.logout_view, name='logout'),
    path('get_friends/', views.get_friends_list, name='get_friends'),
    path('send_friend_request/<int:user_id>/', views.send_friend_request, name='send_friend_request'),
    path('accept_friend_request/<int:friendship_id>/', views.accept_friend_request, name='accept_friend_request'),
    path('reject_friend_request/<int:friendship_id>/', views.reject_friend_request, name='reject_friend_request'),
    path('remove_friend/<int:user_id>/', views.remove_friend, name='remove_friend'),
    path('forgot_password/', views.forgot_password, name='forgot_password'),
    path('forgot_change_password/', views.forgot_change_password, name='forgot_change_password'),
    path('user_password_change/', views.user_password_change, name='user_password_change'),
    path('get_user/', views.get_user, name='get_user'),
    path('signup_email_otp/', views.signup_email_otp, name='signup_email_otp'),
]

import secrets
from .models import OneTimePasscode
from .models import SignupOneTimePasscode
from django.contrib.auth import get_user_model

User = get_user_model()


def create_otp_for_user(user):
    try:
        otp_code = secrets.randbelow(900000) + 100000

        OneTimePasscode.objects.filter(user=user).delete()

        otp = OneTimePasscode.objects.create(
            user=user,
            code=otp_code
        )
        return otp
    except Exception:
        return None

def create_otp_signup(email):
    try:
        otp_code = secrets.randbelow(900000) + 100000

        SignupOneTimePasscode.objects.filter(email=email).delete()

        otp = SignupOneTimePasscode.objects.create(
            email=email,
            code=otp_code
        )
        return otp
    except Exception:
        return None# ================================
# akolgano
# ================================

from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.response import Response
from rest_framework import status
from rest_framework.authtoken.models import Token
from django.contrib.auth import get_user_model
from django.shortcuts import get_object_or_404
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated
from django.http import Http404
from django.utils import timezone
from .serializers import UserSerializer, FriendSerializer
#from .models import CustomUser, Friendship
from .models import Friendship
from django.http import JsonResponse
from django.db.models import Q
from . import email_sender
from . import utils
from .models import OneTimePasscode
from .models import SignupOneTimePasscode
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from apps.remote_auth.models import SocialNetwork

User = get_user_model()

@api_view(['POST'])
def login_view(request):
    username = request.data.get('username')
    try:
        user = get_object_or_404(User, username=username)
    except Http404:
        return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)
    if not user.check_password(request.data['password']):
        return Response({"detail": "Not found."}, status=status.HTTP_404_NOT_FOUND)
    token, created = Token.objects.get_or_create(user=user)
    serializer = UserSerializer(user)
    user.last_activity = timezone.now()
    user.save()
    return Response({'token': token.key, 'user': serializer.data})


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def logout_view(request):
    username = request.data.get('username')
    try:
        user = get_object_or_404(User, username=username)
    except Http404:
        return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        request.user.auth_token.delete()
        user.save()
        return Response("Logout successfully")
    except Exception:
        return Response({"detail": "Logout failed."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def signup(request):
    otp_code = request.data.get('otp')
    email = request.data.get('email')

    otp = SignupOneTimePasscode.objects.filter(email=email, expired_at__gt=timezone.now()).first()
    if not otp:
        return JsonResponse({'error': 'Signup OTP not found or expired.'}, status=status.HTTP_400_BAD_REQUEST)

    if otp.code != otp_code:
        return JsonResponse({'error': 'Signup OTP not match'}, status=status.HTTP_400_BAD_REQUEST)

    social = SocialNetwork.objects.filter(email=email).first()
    if social:
        return JsonResponse({'error': 'Email already in use.'}, status=status.HTTP_400_BAD_REQUEST)

    serializer = UserSerializer(data=request.data)
    if serializer.is_valid():
        user = serializer.save()
        token = Token.objects.create(user=user)
        response_data = {
            'token': token.key,
            'user': serializer.data
        }
        return Response(response_data, status=status.HTTP_201_CREATED)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def test_token(request):
    return Response("passed!")



@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def remove_friend(request, user_id):
    friendship = Friendship.objects.filter(
        Q(from_user=request.user, to_user=user_id) | Q(from_user=user_id, to_user=request.user))
    if not friendship:
        return JsonResponse({'message': 'You are not friends with this user.'}, status=status.HTTP_400_BAD_REQUEST)

    friendship.delete()
    return JsonResponse({'message': 'Friend removed successfully.'}, status=status.HTTP_200_OK)

@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def get_friends_list(request):
    user = request.user
    try:

        friends = Friendship.objects.filter(
        Q(from_user=request.user) | Q(to_user=request.user))
        friends_list = []
        for friend in friends:
            if friend.from_user.username == request.user.username:
                friend_id = friend.to_user.id
            else:
                friend_id = friend.from_user.id

            friends_list.append(friend_id)
        return JsonResponse({'friends': friends_list})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def send_friend_request(request, user_id):
    to_user = get_object_or_404(User, id=user_id)
    if request.user.username == to_user.username:
        return JsonResponse({'message': 'You cannot add yourself as a friend.'}, status=status.HTTP_400_BAD_REQUEST)
    existing_friendship = Friendship.objects.filter(
        from_user=request.user, to_user=to_user
    ).first()

    if existing_friendship:
        return JsonResponse({'message': 'You already have a pending friend request or are already friends.'}, status=status.HTTP_400_BAD_REQUEST)
    friendship = Friendship.objects.create(from_user=request.user, to_user=to_user, status='pending')
    return JsonResponse({
        'message': f'Friend request sent to {to_user.username}.',
        'friend_id': to_user.id,
        'friendship_id': friendship.id,
    }, status=200)

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def accept_friend_request(request, friendship_id):
    friendship = get_object_or_404(Friendship, id=friendship_id, to_user=request.user, status='pending')
    friendship.status = 'accepted'
    friendship.save()
    return JsonResponse({
            "message": f'You are now friends with {friendship.from_user.username}!',
    }, status=200)

@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def reject_friend_request(request, friendship_id):
    friendship = get_object_or_404(Friendship, id=friendship_id, to_user=request.user, status='pending')
    
    friendship.delete()
    return JsonResponse({
            "message": f'Friend request with {friendship.from_user.username} rejected!',
    }, status=200)


@api_view(['POST'])
def forgot_password(request):
    email = request.data.get('email')
    if not email:
        return JsonResponse({'error': 'Invalid email.'}, status=status.HTTP_400_BAD_REQUEST)

    user = User.objects.filter(email=email).first()
    if not user:
        return JsonResponse({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

    if not user.has_usable_password():
        return JsonResponse({'error': 'User passwords cannot be reset.'}, status=status.HTTP_400_BAD_REQUEST)

    otp = utils.create_otp_for_user(user)

    if not otp:
        return JsonResponse({'error': 'OTP creation failed.'}, status=status.HTTP_404_NOT_FOUND)

    try:
        email_sender.send_forgot_password_email(otp.code, email, user.username)
    except Exception:
        return JsonResponse({'error': 'OTP email send failed.'}, status=status.HTTP_400_BAD_REQUEST)

    return JsonResponse({'username': user.username, 'email': user.email}, status=status.HTTP_200_OK)


@api_view(['POST'])
def forgot_change_password(request):
    email = request.data.get('email')
    otp_code = request.data.get('otp')
    password = request.data.get('password')

    if not email or not otp_code or not password:
        return JsonResponse({'error': 'Invalid email, otp or password.'}, status=status.HTTP_400_BAD_REQUEST)

    user = User.objects.filter(email=email).first()    
    if not user:
        return JsonResponse({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

    if not user.has_usable_password():
        return JsonResponse({'error': 'User passwords cannot be reset.'}, status=status.HTTP_400_BAD_REQUEST)

    otp = OneTimePasscode.objects.filter(user=user, expired_at__gt=timezone.now()).first()
    if not otp:
        return JsonResponse({'error': 'OTP not found or expired.'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        validate_password(password)
    except ValidationError as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    if otp.code == otp_code:
        user.set_password(password)
        user.save()
        return JsonResponse({'username': user.username, 'email' : user.email}, status=status.HTTP_200_OK)
    else:
        return JsonResponse({'error': 'OTP not match'}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def user_password_change(request):
    current_password = request.data.get('currentPassword')
    new_password = request.data.get('newPassword')
    user = request.user

    if not user.has_usable_password():
        return JsonResponse({'error': 'User passwords cannot be change.'}, status=status.HTTP_400_BAD_REQUEST)

    if not user.check_password(current_password):
        return JsonResponse({'error': 'Current passwords not match.'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        validate_password(new_password)
    except ValidationError as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    user.set_password(new_password)
    user.save()
    return JsonResponse({'username': user.username, 'email' : user.email}, status=status.HTTP_200_OK)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([IsAuthenticated])
def get_user(request):
    user = request.user

    try:
        data = {
            'username': user.username,
            'id': user.id,
            'email': user.email,
            'has_social_account': False,
            'is_password_usable': user.has_usable_password(),        
        }
        social = SocialNetwork.objects.filter(user=user).first()
        if social:
            data.update({
                'has_social_account': True,
                'social': {
                    'type': social.type,
                    'social_id': social.social_id,
                    'social_email': social.email,
                    'social_name': social.name
                }
            })
        return JsonResponse(data, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
def signup_email_otp(request):
    email = request.data.get('email')

    if not email:
        return JsonResponse({'error': 'Invalid email'}, status=status.HTTP_400_BAD_REQUEST)
    
    otp = utils.create_otp_signup(email)

    if not otp:
        return JsonResponse({'error': 'Signup OTP creation failed.'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        email_sender.send_signup_otp_email(otp.code, email)
    except Exception:
        return JsonResponse({'error': 'Signup OTP email send failed.'}, status=status.HTTP_400_BAD_REQUEST)

    return JsonResponse({'email': email}, status=status.HTTP_200_OK)
